```void laborator6()
{
	// parameters for calcOpticalFlowPyrLK
	vector<Point2f> prev_pts; // vector of 2D points with previous image features
	vector<Point2f> crnt_pts;// vector of 2D points with current image (matched) features
	vector<uchar> status; // output status vector: 1 if the wlow for the corresponding feature was found. 0 otherwise
	vector<float> error; // output vector of errors; each element of the vector is set to an error for the corresponding feature
	Size winSize = Size(21, 21); // size of the search window at each pyramid level - deafult (21,21)
	int maxLevel = 3; // maximal pyramid level number - deafult 3
	//parameter, specifying the termination criteria of the iterative search algorithm
	// (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon
	// deafult 30, 0.01
	TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 20, 0.03);
	int flags = 0;
	double minEigThreshold = 1e-4;
	float lambda = 10;
	Mat prev,crnt,flow;
	double t = (double)getTickCount();
	int n0 = 8;
	char folderName[MAX_PATH];
	if (openFolderDlg(folderName) == 0)
		return;
	char fname[MAX_PATH];
	FileGetter fg(folderName, "bmp");
	int frameNum = -1;
	fg.getNextAbsFile(fname);
	prev = imread(fname, IMREAD_GRAYSCALE);
	while (fg.getNextAbsFile(fname))
	{
		crnt = imread(fname, CV_LOAD_IMAGE_GRAYSCALE);
		GaussianBlur(crnt, crnt, Size(5, 5), 0.8, 0.8);
		++frameNum;
		if (frameNum > 0)
		{
			Mat vx = Mat::zeros(crnt.size(), CV_32FC1); // matricea comp. x a fluxului optic
			Mat vy = Mat::zeros(crnt.size(), CV_32FC1); // matricea comp. y a fluxului optic
			Mat Et = Mat::zeros(crnt.size(), CV_32FC1); // derivatele temporale
			Mat Ex, Ey; // Matricele derivatelor spatiale (gradient)
			// Calcul componenta orizontala a gradientului
			Sobel(crnt, Ex, CV_32F, 1, 0);
			// Calcul componenta verticala a gradientului
			Sobel(crnt, Ey, CV_32F, 0, 1);
			// Calcul derivata temporala
			Mat prev_float, crnt_float; // matricile imaginii crnt sip rev se convertesc in float
			prev.convertTo(prev_float, CV_32FC1);
			crnt.convertTo(crnt_float, CV_32FC1);
			Et = crnt_float - prev_float;
			// Insercati codul aferent algoritmului Horn-Schunk
			for(int i=0; i<n0;i++)
			{
				for (int x = 1; x < crnt.rows-1; x++)
				{
					for (int y = 1; y < crnt.cols-1; y++)
					{
						vx.at<float>(x, y) = (vx.at<float>(x-1, y) + vx.at<float>(x, y-1) + vx.at<float>(x+1, y) + vx.at<float>(x, y+1)) / 4;
						vy.at<float>(x, y) = (vy.at<float>(x - 1, y) + vy.at<float>(x, y - 1) + vy.at<float>(x + 1, y) + vy.at<float>(x, y + 1)) / 4;
						float alpha = lambda * (Ex.at<float>(x, y) * vx.at<float>(x, y) + Ey.at<float>(x, y) * vy.at<float>(x, y) + Et.at<float>(x, y)) / (1 + lambda * (Ex.at<float>(x, y) * Ex.at<float>(x, y) + Ey.at<float>(x, y) * Ey.at<float>(x, y)));
						vx.at<float>(x, y) = vx.at<float>(x, y) - alpha * Ex.at<float>(x, y);
						vy.at<float>(x, y) = vy.at<float>(x, y) - alpha * Ey.at<float>(x, y);
					}
				}
			}
			// . . .
			// Compune comp. x si y ale fluxului optic intr-o matrice cu elemente de tip Point2f
			flow = convert2flow(vx, vy);
			// Vizualizare rezultate intermediare:
			// gradient,derivata temporala si componentele vectorilor de miscare sub forma unor
			// imagini grayscale obtinute din matricile de tip float prin normalizare
			Mat Ex_gray, Ey_gray, Et_gray, vx_gray, vy_gray;
			normalize(Ex, Ex_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
			normalize(Ey, Ey_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
			normalize(Et, Et_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
			normalize(vx, vx_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
			normalize(vy, vy_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
			imshow("Ex", Ex_gray);
			imshow("Ey", Ey_gray);
			imshow("Et", Et_gray);
			imshow("vx", vx_gray);
			imshow("vy", vy_gray);
			t = ((double)getTickCount() - t) / getTickFrequency();
			printf("%d - %.3f [ms]\n", frameNum, t * 1000);
			showFlow("Flow", prev, flow, 1, 1, true, true, false);
			goodFeaturesToTrack(prev, prev_pts, 120, 0.1, 7, Mat(), 3, true);
			calcOpticalFlowPyrLK(prev, crnt, prev_pts, crnt_pts, status, error,
				winSize, maxLevel, criteria);
			showFlowSparse("Error", prev, prev_pts, crnt_pts, status, error, 2, true, true, true);
		}
		prev = crnt.clone();
		if (cv::waitKey() == 27) //ESC pressed
			break;
	}
}```
