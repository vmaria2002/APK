//lab7
	void calcOpticalFlowHS(const Mat& prev, const Mat& crnt, float lambda, int n0, Mat& flow)
	{
		Mat vx = Mat::zeros(crnt.size(), CV_32FC1);
		Mat vy = Mat::zeros(crnt.size(), CV_32FC1);
		Mat Et = Mat::zeros(crnt.size(), CV_32FC1);
		Mat Ex, Ey;
		Sobel(crnt, Ex, CV_32F, 1, 0);
		Sobel(crnt, Ey, CV_32F, 0, 1);
		Mat prev_float, crnt_float;
		prev.convertTo(prev_float, CV_32FC1);
		crnt.convertTo(crnt_float, CV_32FC1);
		Et = crnt_float - prev_float;

		for (int itNo = 0; itNo < n0; itNo++)
		{
			for (int i = 1; i < vx.rows - 1; i++)
			{
				for (int j = 1; j < vx.cols - 1; j++)
				{
					vx.at<float>(i, j) = (vx.at<float>(i - 1, j) + vx.at<float>(i, j + 1) +
						vx.at<float>(i, j - 1) + vx.at<float>(i + 1, j)) / 4;
					vy.at<float>(i, j) = (vy.at<float>(i - 1, j) + vy.at<float>(i, j + 1) +
						vy.at<float>(i, j - 1) + vy.at<float>(i + 1, j)) / 4;
					float alfa;
					alfa = lambda * (Ex.at<float>(i, j) * vx.at<float>(i, j) + Ey.at<float>(i, j) * vy.at<float>(i, j) + Et.at<float>(i, j))
						/ (1 + lambda * (Ex.at<float>(i, j) * Ex.at<float>(i, j) + Ey.at<float>(i, j) * Ey.at<float>(i, j)));
					vx.at<float>(i, j) = vx.at<float>(i, j) - alfa * Ex.at<float>(i, j);
					vy.at<float>(i, j) = vy.at<float>(i, j) - alfa * Ey.at<float>(i, j);
				}
			}

		}

		flow = convert2flow(vx, vy);
		Mat Ex_gray, Ey_gray, Et_gray, vx_gray, vy_gray;
		normalize(Ex, Ex_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
		normalize(Ey, Ey_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
		normalize(Et, Et_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
		normalize(vx, vx_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
		normalize(vy, vy_gray, 0, 255, NORM_MINMAX, CV_8UC1, Mat());
		imshow("Ex", Ex_gray);
		imshow("Ey", Ey_gray);
		imshow("Et", Et_gray);
		imshow("vx", vx_gray);
		imshow("vy", vy_gray);
	}


	void Horn_Schunk()
	{
		Mat frame, crnt;
		Mat prev;
		Mat dst;
		Mat flow;
		char folderName[MAX_PATH];
		char fname[MAX_PATH];
		if (openFolderDlg(folderName) == 0)
			return;
		FileGetter fg(folderName, "bmp");
		int n = 8;
		float lambda = 10.0f;
		int frameNum = -1;
		while (fg.getNextAbsFile(fname))
		{
			crnt = imread(fname, CV_LOAD_IMAGE_GRAYSCALE);
			cvMoveWindow("DST", 10 + crnt.cols, 0);
			GaussianBlur(crnt, crnt, Size(5, 5), 0.8, 0.8);
			++frameNum;


			if (frameNum > 0)
			{
				double t = (double)getTickCount();
				calcOpticalFlowHS(prev, crnt, lambda, n, flow);
				t = ((double)getTickCount() - t) / getTickFrequency();
				printf("%d - %.3f [ms]\n", frameNum, t * 1000);
				showFlow("DST", prev, flow, 1, 1.5, true, true, false);

			}
			imshow("Original", crnt);
			prev = crnt.clone();
			int c = cvWaitKey(0);
			if (c == 27) {
				printf("ESC pressed - playback finished\n\n");
			}
		}
	}


	void flux() {

		VideoCapture cap("Videos/S3.avi");
		if (!cap.isOpened()) {
			printf("Cannot open video capture device.\n");
			waitKey();
			return;
		}

		Mat frame, crnt;
		Mat prev;
		Mat dst;
		Mat flow;
		char c;

		int frameNum = -1;

		for (;;) {
			cap >> frame;
			if (frame.empty())
			{
				printf("End of video file\n");
				break;
			}
			++frameNum;
			if (frameNum == 0)
				imshow("sursa", frame);
			cvtColor(frame, crnt, CV_BGR2GRAY);

			GaussianBlur(crnt, crnt, Size(5, 5), 0.8, 0.8);

			if (frameNum > 0)
			{
				vector<Point2f> prev_pts;
				vector<Point2f> crnt_pts;
				vector<uchar> status;
				vector<float> error;
				Size winSize = Size(21, 21);
				int maxLevel = 3;
				TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 20, 0.03);
				int flags = 0;
				double minEigThreshold = 1e-4;
				vector<Point2f> corners;
				int maxCorners = 100;
				double qualityLevel = 0.01;
				double minDistance = 10;
				int blockSize = 3;
				bool useHarrisDetector = true;
				double k = 0.04;
				goodFeaturesToTrack(prev,
					prev_pts,
					maxCorners,
					qualityLevel,
					minDistance,
					Mat(),
					blockSize,
					useHarrisDetector,
					k);
				calcOpticalFlowPyrLK(prev, crnt, prev_pts, crnt_pts, status, error, winSize, maxLevel, criteria);
				showFlowSparse("rez", prev, prev_pts, crnt_pts, status, error, 1.5, true, true, true);
			}
			prev = crnt.clone();
			c = cvWaitKey(0);
			if (c == 27) {
				printf("ESC pressed - playback finished\n\n");
				break;
			}
		}
	}
